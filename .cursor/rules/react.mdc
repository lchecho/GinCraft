---
description: Cursor Rules for this React Project (React 前端项目开发规则)
alwaysApply: false
---
# Cursor Rules for this React Project (React 前端项目开发规则)
# This file guides the AI to follow modern best practices for React development.
# The tech stack is based on React, TypeScript, and Vite.

## 核心原则 (Core Principles)

1.  **组件化思维 (Component-Based)**: 一切皆为组件。UI 和逻辑应该被拆分为可复用、独立的组件。
2.  **声明式编程 (Declarative Code)**: 只需描述你想要的 UI 状态，让 React 来处理 DOM 的更新。避免直接操作 DOM。
3.  **单向数据流 (Unidirectional Data Flow)**: 数据流动应该是自上而下的（父组件到子组件），这使得状态变更更易于追踪和预测。

## 技术选型与工具链 (Tech Stack & Tooling)

1.  **框架 (Framework)**: **React**。
2.  **构建工具 (Build Tool)**: **Vite**。优先使用 Vite 创建和管理项目，而不是 Create React App (CRA)。
3.  **语言 (Language)**: **TypeScript**。所有新组件和逻辑都必须使用 TypeScript (`.tsx`, `.ts`) 编写，强制类型安全。
4.  **代码质量 (Code Quality)**:
    * **ESLint**: 用于代码规范和错误检查。
    * **Prettier**: 用于代码格式化。两者必须集成，以 Prettier 的格式为准。
    * **配置**: AI 生成的代码必须通过预设的 ESLint 和 Prettier 校验。

## 组件设计 (Component Design)

1.  **函数式组件与 Hooks (Functional Components & Hooks)**:
    * **必须**使用函数式组件和 Hooks。**严禁使用** Class 组件。
    * **必须**遵循 Hooks 的使用规则（只在顶层调用，只在 React 函数中调用）。
2.  **Props 类型定义**:
    * **必须**为每个组件的 props 定义 TypeScript 接口或类型（`type Props = {...}` 或 `interface Props {...}`）。
    * 在函数签名中，使用对象解构来获取 props，并附上类型定义。
    ```tsx
    interface UserCardProps {
      userId: number;
      name: string;
      onSelect: (id: number) => void;
    }

    // 正确
    export const UserCard = ({ userId, name, onSelect }: UserCardProps) => {
      // ...
    };
    ```
3.  **组合优于继承 (Composition over Inheritance)**: 使用组件组合和 props 来复用 UI 和逻辑，而不是采用 Class 继承。
4.  **Key 是必须的**: 在渲染列表时，为每个列表项提供一个稳定且唯一的 `key` prop。
5.  **使用 Fragment**: 当组件需要返回多个同级元素时，使用 Fragment (`<>...</>`) 而不是无意义的 `<div>` 来包裹。

## 状态管理 (State Management)

遵循从简到繁的原则来选择状态管理方案：

1.  **组件本地状态**: 优先使用 `useState`。这是处理组件内部状态的默认和首选方式。
2.  **复杂本地状态**: 当一个组件内有多个状态且它们之间存在联动关系时，使用 `useReducer` 来聚合管理。
3.  **跨组件状态 (简单场景)**: 当需要跨层级传递少量、不频繁更新的状态时，使用 `useContext`。避免用它来管理高频更新的全局状态，以防性能问题。
4.  **全局客户端状态 (复杂场景)**: 当应用需要一个全局、高频更新的状态管理器时，推荐使用 **Zustand** 或 **Jotai**。只有在项目极其庞大和复杂时，才考虑使用 Redux Toolkit。
5.  **服务端状态 (Server State)**: 见下一节“数据请求”。

## 数据请求 (Data Fetching)

1.  **推荐使用 TanStack Query (React Query)**: 对于所有与后端 API 的交互（获取、创建、更新、删除），**强烈推荐**使用 TanStack Query 或 SWR。
2.  **优势**: 这些库能自动处理缓存、请求重试、背景数据同步、加载中/错误状态等，极大简化了数据获取逻辑。
3.  **封装为自定义 Hook**: 将数据请求逻辑封装在自定义 Hook 中，使其在组件中更易于复用和维护。
    ```tsx
    // 示例: useUsers.ts
    import { useQuery } from '@tanstack/react-query';
    import { fetchUsers } from '@/api/users';

    export const useUsers = () => {
      return useQuery({ queryKey: ['users'], queryFn: fetchUsers });
    };
    ```

## 样式方案 (Styling)

1.  **默认使用 CSS Modules**: 推荐使用 CSS Modules (`.module.css` 或 `.module.scss`) 作为组件样式的默认方案，以实现样式的局部作用域，避免全局污染。
    ```tsx
    import styles from './MyComponent.module.css';

    const MyComponent = () => {
      return <div className={styles.container}>Hello</div>;
    };
    ```
2.  **避免内联样式**: 除非是用于处理动态计算的样式（如动画、坐标），否则**禁止**使用 `style` prop 来编写静态样式。
3.  **备选方案**: 如果项目统一采用 **Tailwind CSS** 或 **Styled-components** (Emotion)，则所有新代码都应遵循该方案。

## 代码风格与质量 (Code Style & Quality)

1.  **命名规范**:
    * **组件**: `PascalCase`，例如 `UserProfile`。
    * **自定义 Hooks**: `use` + `camelCase`，例如 `useUserData`。
    * **普通函数/变量**: `camelCase`。
2.  **文件导出**: **优先使用命名导出 (named exports)**，而不是默认导出 (default export)。这有助于代码重构、查找引用和保持一致性。
    ```tsx
    // 正确
    export const MyComponent = () => { ... };

    // 避免
    // export default MyComponent;
    ```
3.  **导入顺序**: `import` 语句应进行分组，顺序如下：
    1.  React 及相关库 (`import React from 'react';`)
    2.  外部第三方库
    3.  内部绝对路径导入 (`@/components/...`)
    4.  内部相对路径导入 (`./...`, `../...`)
4.  **绝对路径导入**: 配置并使用绝对路径导入 (`@/` 指向 `src/`) 来避免深层嵌套的相对路径 (`../../../`)。

## 项目结构 (Project Structure)

1.  **按功能组织 (Feature-based)**: 推荐按功能或业务领域来组织文件，而不是按文件类型。
    ```
    src/
    ├── features/
    │   ├── auth/
    │   │   ├── components/
    │   │   │   └── LoginForm.tsx
    │   │   ├── hooks/
    │   │   │   └── useAuth.ts
    │   │   └── index.ts
    │   └── ...
    ├── components/ (存放跨功能共享的通用组件)
    ├── lib/ (存放通用工具函数)
    ├── pages/ (存放页面级组件)
    └── ...
    ```
2.  **组件文件同置 (Co-location)**: 对于一个独立的组件，建议将其相关文件（样式、测试、故事书）放在同一个文件夹下。

## 禁止事项 (Prohibitions)

1.  **禁止使用 Class 组件和生命周期方法** (如 `componentDidMount`)。
2.  **禁止直接操作 DOM** (使用 `useRef` 只应作为最后的手段)。
3.  **禁止深层 Props 传递 (Prop Drilling)**: 如果一个 prop 需要穿透超过2-3层组件，应考虑使用 `Context` 或其他状态管理方案。
4.  **禁止在组件内部定义组件**: 不要在-一个组件的渲染函数内部定义另一个组件，这会导致性能问题和状态丢失。